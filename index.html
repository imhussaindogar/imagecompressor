<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multiple Image Optimizer — Upload + Bulk URLs (Light/Dark)</title>
<!-- Add Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<style>
  /* ---------- Fonts & reset ---------- */
  @font-face {
    font-family: "InterVar";
    src: local("Inter"), local("Inter var");
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html,body { height: 100%; }

  /* ---------- Improved dark theme with Tailwind ---------- */
  :root {
    --bg: #f5f7fb;
    --card: #ffffff;
    --muted: #6b7280;
    --text: #111827;
    --accent: #115e59;
    --accent-2: #10b981;
    --danger: #dc2626;
    --border: #e6e9ef;
    --shadow: 0 6px 18px rgba(16,24,40,0.06);
    --glass: rgba(255,255,255,0.6);
  }
  [data-theme="dark"] {
    --bg: #0f172a;
    --card: #1e293b;
    --muted: #94a3b8;
    --text: #f1f5f9;
    --accent: #22c55e;
    --accent-2: #10b981;
    --danger: #ef4444;
    --border: #334155;
    --shadow: 0 6px 20px rgba(0,0,0,0.4);
    --glass: rgba(30,41,59,0.6);
  }

  body {
    background: linear-gradient(180deg,var(--bg), rgba(0,0,0,0.02));
    color: var(--text);
    font-family: InterVar, Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    max-width: 1100px;
    margin: 28px auto;
    padding: 22px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    line-height: 1.45;
  }

  /* ---------- Header ---------- */
  header { display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px; }
  h1 { font-size:1.25rem; font-weight:700; margin:0; }
  .sub { color:var(--muted); font-size:0.9rem; }

  /* ---------- Controls ---------- */
  .card { 
    background:var(--card); 
    border:1px solid var(--border); 
    border-radius:12px; 
    padding:14px; 
    box-shadow:var(--shadow);
    backdrop-filter: blur(10px);
  }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .col { display:flex; flex-direction:column; gap:8px; }

  textarea, input[type="text"], select {
    background:transparent; 
    border:1px solid var(--border); 
    padding:10px 12px; 
    border-radius:8px; 
    color:var(--text);
    min-width:0; 
    outline:none;
    transition: border-color 0.2s ease;
  }
  textarea:focus, input[type="text"]:focus, select:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
  }
  textarea { min-height:96px; resize:vertical; width:100%; }
  .small { font-size:0.88rem; color:var(--muted); }

  .btn {
    display:inline-flex; 
    align-items:center; 
    gap:8px;
    background:linear-gradient(180deg,var(--accent), var(--accent-2)); 
    color:white; 
    border:none; 
    padding:10px 14px; 
    border-radius:10px;
    cursor:pointer; 
    font-weight:600;
    transition: all 0.2s ease;
  }
  .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .btn.secondary { 
    background:transparent; 
    border:1px solid var(--border); 
    color:var(--text);
  }
  .btn.ghost { 
    background:transparent; 
    border: 1px dashed var(--border); 
    color:var(--muted);
  }

  .upload-label { 
    cursor:pointer; 
    padding:10px 12px; 
    border-radius:8px; 
    border:1px solid var(--border); 
    color:var(--muted); 
    background:var(--glass);
    transition: all 0.2s ease;
  }
  .upload-label:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  /* ---------- Drop zone ---------- */
  #dropZone { 
    margin-top:12px; 
    padding:20px; 
    text-align:center; 
    border-radius:10px; 
    border:2px dashed var(--border); 
    background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); 
    cursor:pointer;
    transition: all 0.3s ease;
  }
  #dropZone.drag { 
    border-color:var(--accent); 
    box-shadow: 0 8px 30px rgba(16,185,129,0.2);
    background: rgba(34, 197, 94, 0.05);
  }

  /* ---------- Options ---------- */
  .controls-grid { display:flex; gap:12px; align-items:center; margin-top:12px; flex-wrap:wrap; }
  select, input[type="range"] { padding:8px; }
  input[type="range"] {
    -webkit-appearance: none;
    height: 6px;
    background: var(--border);
    border-radius: 3px;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
  }
  #qualityValue { font-weight:700; color:var(--accent); min-width:48px; text-align:center; }

  /* ---------- Preview list ---------- */
  .preview-container { 
    margin-top:18px; 
    display:flex; 
    flex-direction:column; 
    gap:14px; 
  }
  .preview { 
    display:flex; 
    gap:14px; 
    padding:12px; 
    border-radius:10px; 
    align-items:flex-start; 
    border:1px solid var(--border); 
    background:linear-gradient(180deg, transparent, rgba(0,0,0,0.01));
    transition: all 0.2s ease;
  }
  .preview:hover {
    border-color: var(--accent);
    box-shadow: var(--shadow);
  }
  .preview .left { width:160px; flex-shrink:0; text-align:center; }
  .preview .left img { width:150px; height:auto; border-radius:8px; display:block; margin:0 auto 8px; border:1px solid var(--border); }
  .preview .right { flex:1; display:flex; flex-direction:column; gap:8px; }
  .meta { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .tag { 
    padding:6px 8px; 
    border-radius:8px; 
    background:var(--glass); 
    color:var(--muted); 
    font-size:0.85rem; 
    border:1px solid var(--border);
    backdrop-filter: blur(10px);
  }
  .status { font-weight:700; color:var(--muted); font-size:0.9rem; }

  .download-link { 
    color:var(--accent); 
    text-decoration:none; 
    font-weight:600;
    transition: color 0.2s ease;
  }
  .download-link:hover {
    color: var(--accent-2);
    text-decoration: underline;
  }
  .error { color:var(--danger); font-weight:700; }
  .muted { color:var(--muted); font-size:0.9rem; }

  /* ---------- Footer ---------- */
  footer { 
    margin-top:18px; 
    display:flex; 
    justify-content:space-between; 
    align-items:center; 
    gap:12px; 
    flex-wrap:wrap; 
    padding-top: 16px;
    border-top: 1px solid var(--border);
  }
  .actions { display:flex; gap:10px; }

  /* ---------- Responsive ---------- */
  @media (max-width:900px) {
    .preview { flex-direction:column; align-items:center; text-align:center; }
    .preview .left { width:100%; }
    .preview .right { width:100%; }
    header { flex-direction:column; align-items:flex-start; gap:8px; }
  }

  /* Dark mode improvements with Tailwind */
  [data-theme="dark"] .card {
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
  }
  [data-theme="dark"] .btn {
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
  }
  [data-theme="dark"] .preview {
    background: linear-gradient(135deg, rgba(30,41,59,0.7), rgba(15,23,42,0.7));
  }
</style>
</head>
<body>
  <div id="root" class="page" data-theme="dark">
    <header>
      <div>
        <h1>Multiple Image Optimizer</h1>
        <div class="sub">Upload images, paste bulk URLs, convert/compress and download individually or as ZIP</div>
      </div>

      <div class="row" style="align-items:center;">
        <div class="small" id="themeLabel">Theme</div>
        <button id="themeToggle" class="btn secondary">Toggle Theme</button>
      </div>
    </header>

    <!-- Main controls -->
    <section class="card">
      <div style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;">
        <div style="flex:1;min-width:300px;">
          <label class="small">Paste image URLs (one per line)</label>
          <textarea id="urlArea" placeholder="https://example.com/a.jpg&#10;https://example.com/b.png"></textarea>

          <div style="display:flex;gap:8px;margin-top:8px;align-items:center;flex-wrap:wrap;">
            <button id="addUrlsBtn" class="btn">Add URLs</button>

            <label class="upload-label" title="Upload .txt or .csv with URLs">
              Upload URL list (.txt / .csv)
              <input id="urlFile" type="file" accept=".txt,.csv" style="display:none">
            </label>

            <label class="upload-label" title="Choose local image files">
              Choose Local Images
              <input id="upload" type="file" accept="image/*" multiple style="display:none">
            </label>

            <div class="small muted">Tip: some URLs may fail to fetch due to remote CORS policies (see status)</div>
          </div>

        </div>

        <div style="width:360px;min-width:260px;">
          <div class="col">
            <div class="small">Drag & drop images below (or click the area)</div>
            <div id="dropZone">Drag & Drop Images Here — or click to open file picker</div>

            <div class="controls-grid">
              <div class="row" style="align-items:center;">
                <label class="small" for="format">Output format</label>
                <select id="format">
                  <option value="image/webp">WebP (recommended)</option>
                  <option value="image/jpeg">JPEG</option>
                  <option value="image/png">PNG</option>
                </select>
              </div>

              <div class="row" style="align-items:center;">
                <label class="small" for="quality">Quality</label>
                <input id="quality" type="range" min="10" max="100" step="5" value="80">
                <div id="qualityValue" class="small">80%</div>
              </div>

              <div style="margin-left:auto;">
                <button id="optimizeBtn" class="btn">Optimize Images</button>
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>

    <!-- Error / Info -->
    <div id="error" style="margin-top:12px;display:none;"></div>

    <!-- Preview list -->
    <div class="preview-container card" id="previewContainer" style="margin-top:18px;"></div>

    <!-- Footer actions -->
    <footer>
      <div class="small muted" id="infoText">No images loaded.</div>
      <div class="actions">
        <button id="downloadAllBtn" class="btn ghost" style="display:none">Download All as ZIP</button>
        <button id="clearBtn" class="btn secondary">Clear All</button>
      </div>
    </footer>
  </div>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
  (function(){
    // ---------- Elements ----------
    const root = document.getElementById('root');
    const themeToggle = document.getElementById('themeToggle');
    const themeLabel = document.getElementById('themeLabel');
    const urlArea = document.getElementById('urlArea');
    const addUrlsBtn = document.getElementById('addUrlsBtn');
    const urlFile = document.getElementById('urlFile');
    const uploadInput = document.getElementById('upload');
    const dropZone = document.getElementById('dropZone');
    const previewContainer = document.getElementById('previewContainer');
    const optimizeBtn = document.getElementById('optimizeBtn');
    const formatSelect = document.getElementById('format');
    const qualityInput = document.getElementById('quality');
    const qualityValue = document.getElementById('qualityValue');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const clearBtn = document.getElementById('clearBtn');
    const errorEl = document.getElementById('error');
    const infoText = document.getElementById('infoText');

    // ---------- State ----------
    let allFiles = []; // array of File objects
    let optimizedBlobs = []; // {blob, name}
    let fetchingMap = new Map(); // url -> status

    // ---------- Theme ----------
    function applyTheme(theme){
      root.setAttribute('data-theme', theme);
      localStorage.setItem('imgopt_theme', theme);
      themeToggle.textContent = theme === 'dark' ? 'Switch to Light' : 'Switch to Dark';
      themeLabel.textContent = theme === 'dark' ? 'Dark Mode' : 'Light Mode';
    }
    const savedTheme = localStorage.getItem('imgopt_theme') || 'dark';
    applyTheme(savedTheme);

    themeToggle.addEventListener('click', () => {
      const current = root.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
      applyTheme(current === 'dark' ? 'light' : 'dark');
    });

    // ---------- Quality label ----------
    qualityValue.textContent = qualityInput.value + '%';
    qualityInput.addEventListener('input', () => qualityValue.textContent = qualityInput.value + '%');

    // ---------- Utility helpers ----------
    function showError(msg){
      errorEl.style.display = 'block';
      errorEl.innerHTML = '<div class="error">' + escapeHtml(msg) + '</div>';
    }
    function clearError(){ errorEl.style.display = 'none'; errorEl.innerHTML = ''; }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

    function fileExtFromMime(mime){ return (mime || 'image').split('/').pop().split('+')[0]; }
    function getFileExtension(filename) {
      return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
    }
    
    // FIX 2: Keep original filename with new extension
    function getOptimizedFileName(originalName, outputFormat) {
      const baseName = originalName.replace(/\.[^/.]+$/, "");
      const ext = outputFormat.split('/')[1];
      return `${baseName}.${ext}`;
    }

    function updateInfoText(){
      if(allFiles.length === 0) {
        infoText.textContent = 'No images loaded.';
      } else {
        infoText.textContent = `${allFiles.length} image(s) ready — optimize to produce ${formatSelect.value.split('/')[1].toUpperCase()} files.`;
      }
    }

    // ---------- Drag & Drop ----------
    dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag'); });
    dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('drag'); });
    dropZone.addEventListener('drop', e => {
      e.preventDefault();
      dropZone.classList.remove('drag');
      const items = Array.from(e.dataTransfer.files || []);
      if(items.length) addLocalFiles(items);
    });
    dropZone.addEventListener('click', () => uploadInput.click());

    // ---------- Local file input ----------
    uploadInput.addEventListener('change', () => {
      const files = Array.from(uploadInput.files || []);
      if(files.length) addLocalFiles(files);
      uploadInput.value = '';
    });

    function addLocalFiles(files){
      clearError();
      const imgs = files.filter(f => f && f.type && f.type.startsWith('image/'));
      if(imgs.length === 0) return showError('No image files found in selection.');
      imgs.forEach(f => allFiles.push(f));
      renderPreviews();
      updateInfoText();
    }

    // ---------- URL textarea / file (bulk) ----------
    addUrlsBtn.addEventListener('click', async () => {
      const raw = urlArea.value.trim();
      if(!raw) return showError('Paste one or more image URLs (one per line).');
      const urls = parseUrlText(raw);
      urlArea.value = '';
      await fetchAndAddUrls(urls);
    });

    urlFile.addEventListener('change', async () => {
      const f = urlFile.files[0];
      if(!f) return;
      const text = await f.text();
      const urls = parseUrlText(text);
      urlFile.value = '';
      await fetchAndAddUrls(urls);
    });

    function parseUrlText(text){
      const arr = text.split(/\r?\n|,/).map(s => s.trim()).filter(Boolean);
      return Array.from(new Set(arr));
    }

    // ---------- Fetch & add URLs (with status placeholders & retry) ----------
    async function fetchAndAddUrls(urls){
      clearError();
      if(!urls.length) return;
      
      // Create placeholder entries
      urls.forEach(url => {
        fetchingMap.set(url, { status: 'pending', message: 'Waiting' });
        addUrlStatusPreview(url);
      });

      // Fetch sequentially to avoid bursting
      for(const url of urls){
        try {
          updateUrlStatus(url, 'fetching', 'Fetching...');
          
          // FIX 1: Add CORS proxy fallback for URLs that fail
          let blob;
          try {
            // First try direct fetch
            const resp = await fetch(url);
            if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
            blob = await resp.blob();
            if(!blob.type.startsWith('image/')) throw new Error('Fetched resource is not an image.');
          } catch (directError) {
            console.warn('Direct fetch failed, trying with CORS proxy:', directError);
            
            // Try with CORS proxy if direct fetch fails
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            const proxyResp = await fetch(proxyUrl);
            if(!proxyResp.ok) throw new Error(`CORS proxy failed: HTTP ${proxyResp.status}`);
            blob = await proxyResp.blob();
            if(!blob.type.startsWith('image/')) throw new Error('Fetched resource is not an image.');
          }
          
          // Extract filename from URL or generate one
          let filename;
          try {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            filename = pathname.split('/').pop() || 'image';
            if (!filename.includes('.')) {
              const ext = fileExtFromMime(blob.type);
              filename = `${filename}.${ext}`;
            }
          } catch {
            const ext = fileExtFromMime(blob.type);
            filename = `image-${Date.now()}.${ext}`;
          }
          
          const file = new File([blob], filename, { type: blob.type });
          allFiles.push(file);
          updateUrlStatus(url, 'done', 'Fetched ✓');
          renderPreviews(); // re-render to include newly added file
          updateInfoText();
        } catch (err) {
          console.warn('Fetch URL failed', url, err);
          updateUrlStatus(url, 'error', String(err));
          // leave placeholder so user can retry
        }
      }

      // Summarize
      const failed = Array.from(fetchingMap.entries()).filter(([u,s]) => s.status === 'error');
      if(failed.length) {
        showError(`${failed.length} URL(s) failed to fetch. Click 'Retry' on each failed item or use a CORS proxy if needed.`);
      } else {
        clearError();
      }
    }

    // ---------- Status preview helpers ----------
    function addUrlStatusPreview(url){
      // if preview for same url exists, skip
      if(previewContainer.querySelector(`.preview[data-url="${cssEscape(url)}"]`)) return;
      const div = document.createElement('div');
      div.className = 'preview';
      div.dataset.url = url;
      div.innerHTML = `
        <div class="left"><div style="width:150px;height:90px;border-radius:8px;background:var(--border);display:flex;align-items:center;justify-content:center;color:var(--muted);">URL</div></div>
        <div class="right">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="max-width:70%;word-break:break-all;"><strong>${escapeHtml(url)}</strong></div>
            <div class="meta">
              <div class="tag status" id="status-${encodeURIComponent(url)}">Queued</div>
              <button class="btn secondary" id="retry-${encodeURIComponent(url)}" style="display:none">Retry</button>
            </div>
          </div>
          <div class="muted small" id="msg-${encodeURIComponent(url)}">Waiting to fetch…</div>
        </div>
      `;
      // put URL placeholders at top
      previewContainer.prepend(div);

      // attach retry handler
      setTimeout(() => {
        const retryBtn = document.getElementById(`retry-${encodeURIComponent(url)}`);
        if(retryBtn) retryBtn.addEventListener('click', async () => {
          updateUrlStatus(url, 'fetching', 'Retrying...');
          try {
            let blob;
            try {
              const resp = await fetch(url);
              if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
              blob = await resp.blob();
              if(!blob.type.startsWith('image/')) throw new Error('Not an image');
            } catch {
              const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
              const proxyResp = await fetch(proxyUrl);
              if(!proxyResp.ok) throw new Error(`CORS proxy failed: HTTP ${proxyResp.status}`);
              blob = await proxyResp.blob();
              if(!blob.type.startsWith('image/')) throw new Error('Not an image');
            }
            
            let filename;
            try {
              const urlObj = new URL(url);
              const pathname = urlObj.pathname;
              filename = pathname.split('/').pop() || 'image';
              if (!filename.includes('.')) {
                const ext = fileExtFromMime(blob.type);
                filename = `${filename}.${ext}`;
              }
            } catch {
              const ext = fileExtFromMime(blob.type);
              filename = `image-${Date.now()}.${ext}`;
            }
            
            const file = new File([blob], filename, { type: blob.type });
            allFiles.push(file);
            updateUrlStatus(url, 'done', 'Fetched ✓');
            renderPreviews();
            updateInfoText();
            clearError();
          } catch (err) {
            updateUrlStatus(url, 'error', String(err));
            showError('Retry failed. Many servers block cross-origin fetches. Use a CORS-enabled URL or a proxy.');
          }
        });
      }, 50);
    }

    function updateUrlStatus(url, status, message){
      fetchingMap.set(url, { status, message });
      const esc = encodeURIComponent(url);
      const statusEl = document.getElementById(`status-${esc}`);
      const msgEl = document.getElementById(`msg-${esc}`);
      const retryBtn = document.getElementById(`retry-${esc}`);
      if(statusEl) {
        statusEl.textContent = status === 'done' ? 'Done' : (status === 'fetching' ? 'Fetching' : (status === 'error' ? 'Error' : status));
        statusEl.className = status === 'error' ? 'tag status error' : 'tag status';
      }
      if(msgEl) msgEl.textContent = message || '';
      if(retryBtn) retryBtn.style.display = status === 'error' ? 'inline-flex' : 'none';
    }

    // css escape util
    function cssEscape(s) { return s.replace(/([^\w-])/g, m => '\\' + m); }

    // ---------- Render previews for allFiles ----------
    function renderPreviews(){
      // Clear all previews that are file-based (keep URL status previews)
      // We'll remove all existing file previews and recreate to keep indexes stable
      // Remove any preview that doesn't have data-url attr (those are file previews)
      const urlNodes = Array.from(previewContainer.querySelectorAll('.preview[data-url]'));
      previewContainer.innerHTML = '';
      // re-add URL nodes
      urlNodes.forEach(nd => previewContainer.appendChild(nd));

      allFiles.forEach((file, idx) => {
        // prevent duplicate render if already exists (based on file.name + size)
        if(previewContainer.querySelector(`.preview[data-file="${escapeHtml(file.name)}_${file.size}"]`)) return;

        const div = document.createElement('div');
        div.className = 'preview';
        div.dataset.file = `${escapeHtml(file.name)}_${file.size}`;

        const objectUrl = URL.createObjectURL(file);

        div.innerHTML = `
          <div class="left">
            <img src="${objectUrl}" alt="${escapeHtml(file.name)}" />
            <div class="muted small">${(file.size/1024).toFixed(1)} KB</div>
          </div>
          <div class="right">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="max-width:70%;word-break:break-all;"><strong>${escapeHtml(file.name)}</strong></div>
              <div class="meta">
                <div class="tag">${escapeHtml(file.type || 'unknown')}</div>
                <button class="btn secondary" data-remove="${escapeHtml(file.name)}_${file.size}">Remove</button>
              </div>
            </div>

            <div style="display:flex;gap:12px;align-items:center;margin-top:8px;">
              <div style="flex:1;">
                <div class="small muted">Optimized preview</div>
                <img id="optimg-${idx}" alt="optimized-${idx}" style="max-width:220px;margin-top:8px;border-radius:6px;border:1px solid var(--border);" />
                <div class="muted small" id="optsz-${idx}" style="margin-top:6px"></div>
              </div>

              <div style="min-width:120px;display:flex;flex-direction:column;gap:8px;align-items:flex-end;">
                <a id="dl-${idx}" class="download-link" style="display:none" download>Download</a>
                <div style="width:100%;display:flex;gap:6px;">
                  <button class="btn" data-optimize-one="${idx}" style="flex:1">Optimize</button>
                  <button class="btn secondary" data-preview="${idx}" style="flex:1">Open</button>
                </div>
              </div>
            </div>
          </div>
        `;
        previewContainer.appendChild(div);

        // Attach remove handler
        const removeBtn = div.querySelector(`[data-remove="${escapeHtml(file.name)}_${file.size}"]`);
        if(removeBtn){
          removeBtn.addEventListener('click', () => {
            allFiles = allFiles.filter(f => !(f.name === file.name && f.size === file.size));
            renderPreviews();
            updateInfoText();
          });
        }

        // Attach optimize single handler
        const optOne = div.querySelector(`[data-optimize-one="${idx}"]`);
        if(optOne){
          optOne.addEventListener('click', async () => {
            try {
              optOne.disabled = true;
              optOne.textContent = 'Optimizing…';
              const outputFormat = formatSelect.value;
              const quality = outputFormat === 'image/png' ? undefined : (qualityInput.value / 100);
              const { blob, name } = await optimizeSingleFile(file, outputFormat, quality);
              optimizedBlobs.push({ blob, name });
              const optImg = document.getElementById(`optimg-${idx}`);
              const optSz = document.getElementById(`optsz-${idx}`);
              const dl = document.getElementById(`dl-${idx}`);
              if(optImg) optImg.src = URL.createObjectURL(blob);
              if(optSz) optSz.textContent = `${(blob.size/1024).toFixed(1)} KB • ${outputFormat.split('/')[1].toUpperCase()}`;
              if(dl) { 
                dl.href = URL.createObjectURL(blob); 
                dl.download = name; 
                dl.style.display = 'inline-block'; 
                dl.textContent = 'Download'; 
              }
            } catch (err) {
              console.warn('Single optimize error', err);
              showError('Failed to optimize image. See console for details.');
            } finally {
              optOne.disabled = false;
              optOne.textContent = 'Optimize';
              if(optimizedBlobs.length > 0) downloadAllBtn.style.display = 'inline-block';
            }
          });
        }

        // Attach open preview (in new tab)
        const previewBtn = div.querySelector(`[data-preview="${idx}"]`);
        if(previewBtn){
          previewBtn.addEventListener('click', () => {
            window.open(objectUrl, '_blank');
          });
        }
      });
    }

    // ---------- Optimize all ----------
    optimizeBtn.addEventListener('click', () => optimizeAll());
    async function optimizeAll(){
      clearError();
      if(allFiles.length === 0) return showError('No images loaded to optimize.');
      optimizeBtn.disabled = true;
      optimizeBtn.textContent = 'Optimizing…';
      optimizedBlobs = [];
      downloadAllBtn.style.display = 'none';
      const outputFormat = formatSelect.value;
      const quality = outputFormat === 'image/png' ? undefined : (qualityInput.value / 100);

      // process sequentially
      for(let i=0;i<allFiles.length;i++){
        const file = allFiles[i];
        try {
          const { blob, name } = await optimizeSingleFile(file, outputFormat, quality);
          optimizedBlobs.push({ blob, name });

          // update UI for that index (find position by file.name + size)
          const node = previewContainer.querySelector(`.preview[data-file="${escapeHtml(file.name)}_${file.size}"]`);
          if(node){
            // find index in current render order
            const index = Array.from(previewContainer.querySelectorAll('.preview')).indexOf(node);
            const optImg = node.querySelector(`#optimg-${index}`);
            const optSz = node.querySelector(`#optsz-${index}`);
            const dl = node.querySelector(`#dl-${index}`);
            if(optImg) optImg.src = URL.createObjectURL(blob);
            if(optSz) optSz.textContent = `${(blob.size/1024).toFixed(1)} KB • ${outputFormat.split('/')[1].toUpperCase()}`;
            if(dl) { 
              dl.href = URL.createObjectURL(blob); 
              dl.download = name; 
              dl.style.display = 'inline-block'; 
              dl.textContent = 'Download'; 
            }
          }
        } catch (err) {
          console.warn('Optimize error', allFiles[i].name, err);
          // continue processing others
        }
      }

      if(optimizedBlobs.length > 0) {
        downloadAllBtn.style.display = 'inline-block';
      } else {
        showError('No images were successfully optimized.');
      }

      optimizeBtn.disabled = false;
      optimizeBtn.textContent = 'Optimize Images';
    }

    // ---------- Optimize single file helper ----------
    function optimizeSingleFile(file, outputFormat, quality){
      return new Promise((resolve, reject) => {
        const img = new Image();
        const objectUrl = URL.createObjectURL(file);
        
        // Allow loading images from different origins
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // FIX 2: Use original filename with new extension
            const optimizedName = getOptimizedFileName(file.name, outputFormat);

            if(canvas.toBlob){
              try {
                canvas.toBlob((blob) => {
                  if(!blob) {
                    // fallback to toDataURL
                    try {
                      const dataUrl = canvas.toDataURL(outputFormat, quality);
                      const fallback = dataURLToBlob(dataUrl);
                      URL.revokeObjectURL(objectUrl);
                      resolve({ blob: fallback, name: optimizedName });
                    } catch (e) {
                      URL.revokeObjectURL(objectUrl);
                      reject(e);
                    }
                    return;
                  }
                  
                  if(outputFormat && blob.type !== outputFormat){
                    try {
                      const dataUrl = canvas.toDataURL(outputFormat, quality);
                      const converted = dataURLToBlob(dataUrl);
                      URL.revokeObjectURL(objectUrl);
                      resolve({ blob: converted, name: optimizedName });
                    } catch (e){
                      const name = getOptimizedFileName(file.name, blob.type);
                      URL.revokeObjectURL(objectUrl);
                      resolve({ blob, name });
                    }
                  } else {
                    URL.revokeObjectURL(objectUrl);
                    resolve({ blob, name: optimizedName });
                  }
                }, outputFormat, quality);
              } catch (err) {
                try {
                  const dataUrl = canvas.toDataURL(outputFormat, quality);
                  const blob = dataURLToBlob(dataUrl);
                  URL.revokeObjectURL(objectUrl);
                  resolve({ blob, name: optimizedName });
                } catch(e){
                  URL.revokeObjectURL(objectUrl);
                  reject(e);
                }
              }
            } else {
              try {
                const dataUrl = canvas.toDataURL(outputFormat, quality);
                const blob = dataURLToBlob(dataUrl);
                URL.revokeObjectURL(objectUrl);
                resolve({ blob, name: optimizedName });
              } catch(e){
                URL.revokeObjectURL(objectUrl);
                reject(e);
              }
            }
          } catch (err) {
            URL.revokeObjectURL(objectUrl);
            reject(err);
          }
        };
        img.onerror = (ev) => {
          URL.revokeObjectURL(objectUrl);
          reject(new Error('Failed to load image into canvas (CORS or corrupt file).'));
        };
        img.src = objectUrl;
      });
    }

    // ---------- dataURL -> Blob ----------
    function dataURLToBlob(dataURL){
      const parts = dataURL.split(',');
      const mime = parts[0].match(/:(.*?);/)[1];
      const binary = atob(parts[1]);
      const array = new Uint8Array(binary.length);
      for(let i=0;i<binary.length;i++) array[i] = binary.charCodeAt(i);
      return new Blob([array], { type: mime });
    }

    // ---------- Download all as ZIP ----------
    downloadAllBtn.addEventListener('click', async () => {
      if(optimizedBlobs.length === 0) return showError('No optimized images available to download. Optimize images first.');
      downloadAllBtn.disabled = true;
      downloadAllBtn.textContent = 'Preparing ZIP…';
      try {
        const zip = new JSZip();
        optimizedBlobs.forEach(item => zip.file(item.name, item.blob));
        const content = await zip.generateAsync({ type: 'blob' });
        saveAs(content, 'optimized_images.zip');
      } catch (err) {
        console.error(err);
        showError('Failed to create ZIP file.');
      } finally {
        downloadAllBtn.disabled = false;
        downloadAllBtn.textContent = 'Download All as ZIP';
      }
    });

    // ---------- Clear ----------
    clearBtn.addEventListener('click', () => {
      if(!confirm('Clear all loaded images and previews?')) return;
      allFiles = [];
      optimizedBlobs = [];
      fetchingMap.clear();
      previewContainer.innerHTML = '';
      clearError();
      downloadAllBtn.style.display = 'none';
      updateInfoText();
    });

    // ---------- Helper: convert fetched blobs to Files (not strictly necessary but keeps uniform) ----------
    function blobToFile(blob, filename){
      try { return new File([blob], filename, { type: blob.type }); }
      catch(e){
        // older browsers
        blob.name = filename;
        blob.lastModified = Date.now();
        return blob;
      }
    }

    // ---------- CSS-safe encode ----------
    function encodeForId(s){
      return encodeURIComponent(s).replace(/%/g,'_');
    }

    // ---------- bootstrap: expose fetch via console if needed ----------
    window.__imgopt = { allFiles, optimizedBlobs };

    // ---------- initial state ----------
    updateInfoText();

    // ---------- Notes in console ----------
    console.info('Multiple Image Optimizer loaded. Note: remote URL fetches may fail due to CORS; use CORS-enabled URLs or proxy if needed.');
  })();
  </script>
</body>
</html>
