<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiple Image Optimizer</title>
  <style>
/* (your CSS remains the same — unchanged) */
  </style>
</head>
<body>

<h1>Multiple Image Optimizer</h1>

<!-- ⭐ NEW: Add Image by URL -->
<div style="margin-bottom:20px;">
  <label style="font-size:1rem;">Add Image from URL:</label>
  <input type="text" id="imageUrl" placeholder="https://example.com/image.jpg" 
         style="width:60%;padding:10px;background:#3a3a3a;color:#fff;border:1px solid #444;border-radius:6px;">
  <button onclick="addImageByURL()">Add</button>
</div>

<div id="dropZone">
  <p>Drag & Drop Images Here or Click to Select</p>
  <label for="upload" class="upload-label">Choose Images</label>
  <input type="file" id="upload" accept="image/jpeg,image/png,image/webp" multiple />
</div>

<div>
  <label for="format">Output Format:</label>
  <select id="format">
    <option value="image/jpeg">JPEG</option>
    <option value="image/png">PNG</option>
    <option value="image/webp" selected>WebP</option>
  </select>
</div>

<div>
  <label for="quality">Compression Quality (10% - 100%):</label>
  <input type="range" id="quality" min="10" max="100" step="10" value="80" />
  <span id="qualityValue">80%</span>
</div>

<button onclick="optimizeImages()">Optimize Images</button>

<div id="error"></div>
<div class="preview-container" id="previewContainer"></div>

<button id="downloadAll" style="display:none;" onclick="downloadAllImages()">Download All as ZIP</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<script>
let allFiles = []; // ⭐ NEW: Single array for all local + URL files
let optimizedBlobs = [];

const uploadInput = document.getElementById('upload');
const dropZone = document.getElementById('dropZone');
const previewContainer = document.getElementById('previewContainer');
const downloadAllButton = document.getElementById('downloadAll');
const error = document.getElementById('error');
const qualityInput = document.getElementById('quality');
const qualityValue = document.getElementById('qualityValue');

// Update quality label
qualityInput.addEventListener('input', () => {
  qualityValue.textContent = `${qualityInput.value}%`;
});

// ⭐ FIXED DRAG & DROP
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('dragover');
});

dropZone.addEventListener('dragleave', () => {
  dropZone.classList.remove('dragover');
});

dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const files = Array.from(e.dataTransfer.files);
  addFiles(files);
});

// File input
uploadInput.addEventListener('change', () => {
  const files = Array.from(uploadInput.files);
  addFiles(files);
});

// ---------------------------
// ADD FILES (from upload or URL)
// ---------------------------
function addFiles(files) {
  const valid = files.filter(f => f.type.match("image/"));
  if (valid.length === 0) {
    showError("Please upload only image files.");
    return;
  }
  clearError();
  valid.forEach(file => allFiles.push(file));
  renderPreviews();
}

// ---------------------------
// ⭐ NEW: ADD IMAGE FROM URL
// ---------------------------
async function addImageByURL() {
  const url = document.getElementById("imageUrl").value.trim();
  if (!url) return showError("Please enter an image URL.");

  try {
    const response = await fetch(url);
    const blob = await response.blob();

    if (!blob.type.startsWith("image/")) {
      showError("URL must point to an actual image.");
      return;
    }

    // Convert URL image to File
    const fileName = "url-image-" + Date.now() + "." + blob.type.split("/")[1];
    const file = new File([blob], fileName, { type: blob.type });

    allFiles.push(file);
    clearError();
    renderPreviews();

  } catch (err) {
    showError("Failed to load image from URL.");
  }
}

// ---------------------------
// PREVIEW RENDERER
// ---------------------------
function renderPreviews() {
  previewContainer.innerHTML = "";
  optimizedBlobs = [];
  downloadAllButton.style.display = "none";

  allFiles.forEach((file, index) => {
    const reader = new FileReader();
    reader.onload = () => {
      const div = document.createElement("div");
      div.className = "preview";

      div.innerHTML = `
        <h3>${file.name}</h3>
        <div class="image-pair">
          <div>
            <h4>Original</h4>
            <img src="${reader.result}">
            <p class="image-info">${(file.size / 1024).toFixed(2)} KB</p>
          </div>
          <div>
            <h4>Optimized</h4>
            <img id="optimizedPreview${index}">
            <p id="optimizedSize${index}" class="image-info"></p>
            <a id="downloadLink${index}" class="download-link" style="display:none;">Download</a>
          </div>
        </div>
      `;

      previewContainer.appendChild(div);
    };
    reader.readAsDataURL(file);
  });
}

// ---------------------------
// OPTIMIZER
// ---------------------------
function optimizeImages() {
  if (allFiles.length === 0) return showError("No images selected.");

  clearError();

  const outputFormat = document.getElementById("format").value;
  const quality = outputFormat === 'image/png' ? undefined : qualityInput.value / 100;

  optimizedBlobs = [];

  allFiles.forEach((file, index) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      canvas.getContext("2d").drawImage(img, 0, 0);

      const dataURL = canvas.toDataURL(outputFormat, quality);
      const blob = dataURLtoBlob(dataURL);

      const newName = file.name.split(".")[0] + "." + outputFormat.split("/")[1];
      optimizedBlobs.push({ blob, name: newName });

      // Update preview
      document.getElementById(`optimizedPreview${index}`).src = dataURL;
      document.getElementById(`optimizedSize${index}`).textContent =
        `${(blob.size / 1024).toFixed(2)} KB`;

      const link = document.getElementById(`downloadLink${index}`);
      link.href = URL.createObjectURL(blob);
      link.download = newName;
      link.style.display = "inline";

      if (optimizedBlobs.length === allFiles.length) {
        downloadAllButton.style.display = "block";
      }
    };

    img.src = URL.createObjectURL(file);
  });
}

// Convert Base64 → Blob
function dataURLtoBlob(dataURL) {
  const parts = dataURL.split(',');
  const binary = atob(parts[1]);
  const array = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) array[i] = binary.charCodeAt(i);
  return new Blob([array], { type: parts[0].split(':')[1].split(';')[0] });
}

// ZIP Download
function downloadAllImages() {
  const zip = new JSZip();
  optimizedBlobs.forEach(({ blob, name }) => zip.file(name, blob));

  zip.generateAsync({ type: "blob" }).then(content => {
    saveAs(content, "optimized_images.zip");
  });
}

// Errors
function showError(msg) {
  error.textContent = msg;
  error.style.display = "block";
}

function clearError() {
  error.style.display = "none";
}
</script>

</body>
</html>
